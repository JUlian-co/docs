# Multisig

:::info
Impatient?  Check out [complete examples here](https://github.com/zerodevapp/zerodev-examples/tree/main/multisig/main.ts).
:::

With Kernel, it's possible to configure multiple signers for your smart account. The plugin that supports this functionality is named `WeightedValidator`, which supports multiple signers (including both ECDSA and WebAuthn signers), each having a specific "weight."

## How it works

Each signer is set up with a **weight**, and for any given signature, there must be enough combined weight to reach or surpass the **threshold** for the signature to be considered valid.

For example, let's say we have:

- Threshold: 100
- Weights:
  - Signer A: 100
  - Signer B: 50
  - Signer C: 50

In this case, we are setting up a multisig where either signer A alone (100 = 100), or signer B and C together (50 + 50 = 100) can provide a valid signature.

## Installation

:::code-group
```bash [npm]
npm i @zerodev/weighted-validator
```

```bash [yarn]
yarn add @zerodev/weighted-validator
```

```bash [pnpm]
pnpm i @zerodev/weighted-validator
```

```bash [bun]
bun i @zerodev/weighted-validator
```
:::

## Setting up a new multisig account

To set up a new multisig account, start by creating a validator:

```ts
import { createWeightedValidator } from "@zerodev/weighted-validator"

const multiSigValidator = await createWeightedValidator(publicClient, {
  entryPoint,
  kernelVersion,
  signer, // The current signer being used
  config: {
    threshold: 100,
    signers: [
      { publicKey: signerA, weight: 100 },
      { publicKey: signerB, weight: 50 },
      { publicKey: signerC, weight: 50 },
    ]
  },
})
```

In `config`, you specify the `threshold` and a list of signers along with their weights. Each signer can be either a WebAuthn key or an ECDSA key.

The `signer` parameter specifies the current signer that will be used for signing transactions. The combined weight of the active signers must reach the threshold.

After creating the validator, you can [set up a Kernel account using the validator](/sdk/core-api/create-account#create-a-kernel-account) as usual:

```ts
const account = await createKernelAccount(publicClient, {
  entryPoint,
  kernelVersion,
  plugins: {
    sudo: multiSigValidator,
  }
})

// Create the client
const client = createWeightedKernelAccountClient({
  account,
  chain,
  bundlerTransport: http(BUNDLER_URL),
  // ... other configuration options
})
```

## Using a multisig account

When using a multisig account, sending transactions requires gathering enough signatures to meet the threshold. This is a two-step process:

1. First, get approvals from the required signers
2. Then, send the UserOperation with the collected signatures

Here's how to implement this flow:

```ts
// First, create the UserOperation that needs to be signed
const userOp = await client.prepareUserOperation({
  userOperation: {
    target: targetAddress,
    data: encodeFunctionData(...),
    value: 0n,
  }
})

// Each signer can approve the UserOperation
// This can be done by different signers at different times/places
const sig1 = await client1.approveUserOperation(userOp)
const sig2 = await client2.approveUserOperation(userOp)

// Once you have enough signatures to meet the threshold,
// you can send the UserOperation with all collected signatures
const hash = await client.sendUserOperationWithSignatures(
  userOp,
  [sig1, sig2]
)

// You can wait for the UserOperation to be included in a block
const receipt = await client.waitForUserOperationReceipt(hash)
```

Note that:
- The signatures can be collected asynchronously from different signers
- You need to collect enough signatures to meet the threshold weight
- The same UserOperation object must be used for all signatures
- Each signer must use their own client instance configured with their signer

For example, if you have a threshold of 100 and signers with weights 50 each, you would need signatures from at least two signers to successfully send the transaction.

## Updating multisig config

To update the multisig configuration (like adding or removing signers), you can use the update config functionality:

```ts
import { getUpdateConfigCall } from "@zerodev/weighted-validator"

await kernelClient.sendTransaction(
  getUpdateConfigCall({
    threshold: 100,
    signers: [
      { publicKey: signer1, weight: 50 },
      { publicKey: signer2, weight: 50 },
      { publicKey: signer3, weight: 50 },
    ]
  }),
)
```

Note that `kernelClient` here must itself be a correctly set-up instance of a multisig account client with sufficient signing authority to make the change.